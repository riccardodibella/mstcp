Multi-Stream TCP Congestion Control

ASSUNZIONE DI BASE: i segmenti SACKed non occupano spazio nella congestion window
    - Questa è una modifica "di implementazione". Se uno vuole può gestire la cosa diversamente, "allargando" a mano la cwnd come
    si fa con LTA per "togliere" i segmenti SACKed che però occuperanno quindi ancora spazio, ma non è una modifica che ha effetto
    su quello che viene trasmesso
    - Congettura: l'effetto di questa scelta è concettualmente identico a quello di LTA, 
    - qua si sta parlando solo di cwnd, non di adwin. Questo non è collegato con il meccanismo di adwin inflation descritto
    nel paper

- Gli ACK normali vengono inviati con segmenti DMP, che arrivano in un "treno" al tick successivo di mytimer
- Ad ognuno di questi ACK che arriva, si aumenta la congestion window basandosi su quanti byte sono ACKed da quel segmento
    - Questo consente di gestire in automatico i delayed ACK (incluso accorpamento descritto nella tesi)
    - L'aumento della cwnd è abbastanza basso (soprattutto in congestion avoidance), perchè non include lo spazio già liberato
    dal cumulative ACK
- I dupACK si individuano sempre allo stesso modo: segmenti solo ACK vuoti con ack == last_ack
    - I dupACK arrivano uno alla volta, separati a seconda di come sono arrivati i pacchetti dall'altra parte
    - Quando arriva un dupACK si aumenta il contatore dei dupACK (per eventualmente triggerare fast recovery), ma non si aumenta
    a mano la congestion window
- Sia per cumulative ACK che per SACK, ogni volta che un segmento viene ACKato bisogna diminuire la variabile di canale flightsize,
che considera il numero di byte unacked in volo
    - questo va fatto solo se il segmento ACKed o SACKed non è DMP
    - quando si riduce la lista per cumulative ACK, man mano che si scorre bisogna fare attenzione a non ridurre flightsize per
    segmenti che sono già stati SACKed
- Quando arriva un cumulativeACK, la cwnd viene allargata (se non si è in fast recovery) basandosi sul numero totale di byte
di cui viene fatto l'ACK, a prescindere di se alcuni dei segmenti di cui viene fatto il cumulative ACK prima erano stati SACKed
o meno

- Per avere una struttura concettuale "pulita" si potrebbe fare una FSM piccola che fa solo le transizioni e le modifiche 
alle variabili del TCB, e un wrapper esterno che fa il parsing ai pacchetti, guarda il TCB e decide gli eventi e i parametri
    - Eventi possibili: ACK (con # byte ACKed), dupACK, timeout
- Non serve tenere traccia di quale stream contribuisce agli ACK
    - La funzione per evitare HoL blocking si può tenere nello scheduler, in cui però si da priorità prima a tutti gli stream 
    senza buchi, e poi agli stream che hanno ancora buchi se avanza spazio nella cwnd

- Per compatibilità di overflow exception (non implementata) con il SACK, farei così:
    - Ogni volta che arriva un SACK, si scorre la coda di trasmissione fino a che non si trovano i segmenti SACKed
    - Se è il primo segmento unacked per quello stream, allora faccio unlink del suo payload (che non può essere revocato) e
    segno l'header node come SACKed
    - Se non è il primo segmento unacked per quello stream, quindi c'è un "buco" prima, allora lo segno come SACKed ma lascio
    collegato il payload, perchè potrebbe essere revocato in futuro
    - Se un ricevitore ha intenzione di revocare la ricezione di un payload, deve evitare di inserire quel segmento all'interno
    di un intervallo SACK
        - Questo non permette di avere una conoscenza "perfetta" della possibilità di overflow del segmento appena ricevuto, in
        caso ci sia un buco precedente a quello che si sta SACKando. Però se si tiene una contabilità della memoria per stream
        allora ci si può comunque accorgere della violazione, solo che non per forza con l' "ultimo" segmento della coda, ma
        con uno prima se sono arrivati fuori ordine. Ma non c'è problema: appena ce se ne accorge, non si fa il SACK di tutti
        i segmenti che violano la contabilità, a prescindere dalla memoria. Quando lo si aggiunge alla coda di ricezione, non 
        si inserisce il payload ma solo l'header, però non si attiva il flag SACKed. Volendo si potrebbe usare un altro flag per
        segnalarlo in modo più evidente, ma non è necessario.
        - Bisogna fare attenzione: per tutti i segmenti SACKed successivi a uno di questi sullo stesso stream non va mai
        tolto il payload, fino a quando tutti i buchi prima non sono riempiti o tutti i NACK non sono stati ACKed
        - Andrà capito come "ricostruire" la sequenza corretta al ricevitore una volta che il segmento viene ritrasmesso con
        sequence number diverso, e come si distingue quel segmento da un altro che arriva semplicemente dopo in quella posizione
        - Ci sono un po' di cose da capire, in realtà... Implementandolo in pratica va fatta molta attenzione a tutto, e adesso
        sicuramente non mi vengono in mente tutti i problemi possibili
